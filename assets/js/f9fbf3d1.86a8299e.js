"use strict";(globalThis.webpackChunktemp_docusaurus_init=globalThis.webpackChunktemp_docusaurus_init||[]).push([[4292],{2857:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"module-1/launch-urdf","title":"Robot Description (URDF)","description":"Short Overview","source":"@site/docs/module-1/launch-urdf.mdx","sourceDirName":"module-1","slug":"/module-1/launch-urdf","permalink":"/Physical-AI-Humanoid-Robotics-TextBook/docs/module-1/launch-urdf","draft":false,"unlisted":false,"editUrl":"https://github.com/IdreesKhan12/Physical-AI-Humanoid-Robotics-TextBook/tree/main/docs/module-1/launch-urdf.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Robot Description (URDF)","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Python Agents and rclpy","permalink":"/Physical-AI-Humanoid-Robotics-TextBook/docs/module-1/python-agents-rclpy"},"next":{"title":"Simulation Environment Setup","permalink":"/Physical-AI-Humanoid-Robotics-TextBook/docs/module-2/gazebo-setup"}}');var o=i(4848),s=i(8453);const r={title:"Robot Description (URDF)",sidebar_position:3},a=void 0,l={},d=[{value:"Short Overview",id:"short-overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Main Sections",id:"main-sections",level:2},{value:"1. Introduction to URDF: Describing Your Robot",id:"1-introduction-to-urdf-describing-your-robot",level:3},{value:"2. Links and Joints: The Building Blocks of a Robot",id:"2-links-and-joints-the-building-blocks-of-a-robot",level:3},{value:"Links: The Robot&#39;s Body Parts",id:"links-the-robots-body-parts",level:4},{value:"Joints: Connecting the Parts",id:"joints-connecting-the-parts",level:4},{value:"3. A Minimal URDF Example: Two-Link Arm",id:"3-a-minimal-urdf-example-two-link-arm",level:3},{value:"4. Integrating URDF with the ROS Launch System",id:"4-integrating-urdf-with-the-ros-launch-system",level:3},{value:"Launch Files: Orchestrating Your Robot",id:"launch-files-orchestrating-your-robot",level:4},{value:"Parameter Management with URDF",id:"parameter-management-with-urdf",level:4},{value:"5. URDF and Physics Simulation (Gazebo/SDF)",id:"5-urdf-and-physics-simulation-gazebosdf",level:3},{value:"Summary Key Points",id:"summary-key-points",level:2},{value:"Reading/Research References (APA 7th Edition)",id:"readingresearch-references-apa-7th-edition",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"short-overview",children:"Short Overview"}),"\n",(0,o.jsx)(n.p,{children:"This chapter delves into the Unified Robot Description Format (URDF), an XML-based format crucial for defining robot structures for use in both ROS 2 and Gazebo. You will learn the fundamental components of URDF, including links and joints, and understand how to create a minimal robot model. The chapter also explains the integration of URDF files within the ROS launch system, covering launch files and parameter management."}),"\n",(0,o.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Explain the difference between a ",(0,o.jsx)(n.strong,{children:"link"})," (body part) and a ",(0,o.jsx)(n.strong,{children:"joint"})," (connection) within URDF."]}),"\n",(0,o.jsxs)(n.li,{children:["Provide a minimal, complete ",(0,o.jsx)(n.strong,{children:"URDF XML example"})," for a two-link arm, illustrating fixed and continuous joints."]}),"\n",(0,o.jsx)(n.li,{children:"Explain how the URDF file is integrated via the ROS launch system, including Launch Files and Parameter Management."}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"main-sections",children:"Main Sections"}),"\n",(0,o.jsx)(n.h3,{id:"1-introduction-to-urdf-describing-your-robot",children:"1. Introduction to URDF: Describing Your Robot"}),"\n",(0,o.jsx)(n.p,{children:"The Unified Robot Description Format (URDF) is an XML format for describing all aspects of a robot. It's used to represent the robot's kinematic and dynamic properties, visual appearance, and collision geometry. URDF files are essential for visualizing your robot in tools like RViz, simulating it in Gazebo, and enabling various ROS 2 packages to interact with its structure."}),"\n",(0,o.jsx)(n.h3,{id:"2-links-and-joints-the-building-blocks-of-a-robot",children:"2. Links and Joints: The Building Blocks of a Robot"}),"\n",(0,o.jsxs)(n.p,{children:["At its core, a URDF file defines a robot as a collection of ",(0,o.jsx)(n.strong,{children:"links"})," connected by ",(0,o.jsx)(n.strong,{children:"joints"}),"."]}),"\n",(0,o.jsx)(n.h4,{id:"links-the-robots-body-parts",children:"Links: The Robot's Body Parts"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"link"})," represents a rigid body part of the robot. Think of it as a segment of the robot's body\u2014an arm segment, a wheel, a torso, or a camera housing. Each link has properties such as its name, visual appearance (color, mesh), inertial properties (mass, inertia), and collision geometry (for physics simulation)."]}),"\n",(0,o.jsx)(n.h4,{id:"joints-connecting-the-parts",children:"Joints: Connecting the Parts"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"joint"})," defines the connection between two links, specifically a ",(0,o.jsx)(n.em,{children:"parent"})," link and a ",(0,o.jsx)(n.em,{children:"child"})," link. Joints specify the type of motion allowed between these links (e.g., revolute, prismatic, fixed) and their kinematic properties (axis of rotation, limits of motion)."]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Fixed Joint"}),": No motion allowed between the parent and child link. They move as one rigid body. Useful for connecting sensors or static parts."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Revolute (Continuous) Joint"}),": Allows rotation around a single axis. A ",(0,o.jsx)(n.code,{children:"continuous"})," joint is a type of revolute joint that has no upper or lower limits (e.g., a wheel that can spin infinitely)."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"3-a-minimal-urdf-example-two-link-arm",children:"3. A Minimal URDF Example: Two-Link Arm"}),"\n",(0,o.jsx)(n.p,{children:"Let's construct a simple URDF for a two-link arm. This example illustrates how links and joints are defined and connected."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="two_link_arm">\n\n  \x3c!-- Base Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder length="0.1" radius="0.05"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 0.8 1"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Joint 1: Connects base_link to link1 (Revolute/Continuous) --\x3e\n  <joint name="joint1" type="continuous">\n    <parent link="base_link"/>\n    <child link="link1"/>\n    <origin xyz="0 0 0.1" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n  </joint>\n\n  \x3c!-- Link 1 --\x3e\n  <link name="link1">\n    <visual>\n      <geometry>\n        <cylinder length="0.2" radius="0.03"/>\n      </geometry>\n      <material name="green">\n        <color rgba="0 0.8 0 1"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Joint 2: Connects link1 to link2 (Fixed) --\x3e\n  <joint name="joint2" type="fixed">\n    <parent link="link1"/>\n    <child link="link2"/>\n    <origin xyz="0 0 0.2" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Link 2 (End Effector) --\x3e\n  <link name="link2">\n    <visual>\n      <geometry>\n        <box size="0.05 0.05 0.05"/>\n      </geometry>\n      <material name="red">\n        <color rgba="0.8 0 0 1"/>\n      </material>\n    </visual>\n  </link>\n\n  \x3c!-- Define materials --\x3e\n  <material name="blue">\n    <color rgba="0 0 0.8 1"/>\n  </material>\n  <material name="green">\n    <color rgba="0 0.8 0 1"/>\n  </material>\n  <material name="red">\n    <color rgba="0.8 0 0 1"/>\n  </material>\n\n</robot>\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:'<robot name="two_link_arm">'})}),": The root element, giving the robot a name."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:'<link name="base_link">'})}),": Defines the stationary base of our arm. It has a visual representation (a blue cylinder)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:'<joint name="joint1" type="continuous">'})}),": Connects ",(0,o.jsx)(n.code,{children:"base_link"})," (parent) to ",(0,o.jsx)(n.code,{children:"link1"})," (child). It's a ",(0,o.jsx)(n.code,{children:"continuous"})," joint, allowing full rotation around the Z-axis (",(0,o.jsx)(n.code,{children:'<axis xyz="0 0 1"/>'}),")."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:'<link name="link1">'})}),": The first moving segment, a green cylinder. Its origin ",(0,o.jsx)(n.code,{children:'xyz="0 0 0.1"'})," places it on top of ",(0,o.jsx)(n.code,{children:"base_link"})," visually."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:'<joint name="joint2" type="fixed">'})}),": Connects ",(0,o.jsx)(n.code,{children:"link1"})," to ",(0,o.jsx)(n.code,{children:"link2"}),". It's a ",(0,o.jsx)(n.code,{children:"fixed"})," joint, meaning ",(0,o.jsx)(n.code,{children:"link2"})," is rigidly attached to ",(0,o.jsx)(n.code,{children:"link1"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:'<link name="link2">'})}),": The end-effector, a red box."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<material>"})}),": Defines colors for better visualization."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"4-integrating-urdf-with-the-ros-launch-system",children:"4. Integrating URDF with the ROS Launch System"}),"\n",(0,o.jsxs)(n.p,{children:["URDF files are typically loaded into ROS 2 via the ",(0,o.jsx)(n.strong,{children:"ROS launch system"}),". This system uses ",(0,o.jsx)(n.strong,{children:"Launch Files"})," to define how multiple nodes and robot configurations are started and managed."]}),"\n",(0,o.jsx)(n.h4,{id:"launch-files-orchestrating-your-robot",children:"Launch Files: Orchestrating Your Robot"}),"\n",(0,o.jsxs)(n.p,{children:["A launch file is an XML (or Python in ROS 2) file that allows you to start and configure multiple ROS 2 nodes and parameters with a single command. To load a URDF, you commonly use the ",(0,o.jsx)(n.code,{children:"robot_state_publisher"})," node, which reads the URDF and publishes the robot's joint states as transformations on the ",(0,o.jsx)(n.code,{children:"/tf"})," topic, allowing visualization in tools like RViz."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Example Launch File (Python in ROS 2):"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    # Get URDF file path\n    urdf_file_name = 'two_link_arm.urdf'\n    urdf_path = os.path.join(\n        get_package_share_directory('my_robot_description'), # Replace with your package name\n        'urdf',\n        urdf_file_name)\n\n    # Robot State Publisher Node\n    robot_state_publisher_node = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        name='robot_state_publisher',\n        output='screen',\n        parameters=[{'robot_description': urdf_path}] # Pass URDF path as a parameter\n    )\n\n    # Joint State Publisher Node (for manual joint control/testing)\n    joint_state_publisher_node = Node(\n        package='joint_state_publisher_gui', # Or 'joint_state_publisher'\n        executable='joint_state_publisher_gui',\n        name='joint_state_publisher_gui',\n        output='screen',\n    )\n\n    return LaunchDescription([\n        robot_state_publisher_node,\n        joint_state_publisher_node\n    ])\n"})}),"\n",(0,o.jsx)(n.h4,{id:"parameter-management-with-urdf",children:"Parameter Management with URDF"}),"\n",(0,o.jsxs)(n.p,{children:["In the launch file example above, ",(0,o.jsx)(n.code,{children:"parameters=[{'robot_description': urdf_path}]"})," demonstrates ",(0,o.jsx)(n.strong,{children:"Parameter Management"}),". The ",(0,o.jsx)(n.code,{children:"robot_state_publisher"})," node is configured with a parameter named ",(0,o.jsx)(n.code,{children:"robot_description"}),", whose value is the path to your URDF file. This is a common way to pass configuration data to ROS 2 nodes, allowing the same node executable to behave differently based on the parameters it receives."]}),"\n",(0,o.jsx)(n.h3,{id:"5-urdf-and-physics-simulation-gazebosdf",children:"5. URDF and Physics Simulation (Gazebo/SDF)"}),"\n",(0,o.jsxs)(n.p,{children:["It is important to understand that ",(0,o.jsx)(n.strong,{children:"URDF itself does not contain physics information"}),". While URDF defines the robot's geometry, mass, and inertia, it does not specify how these properties interact in a dynamic environment (like friction, restitution, or sensor properties for simulation). For advanced physics simulation in Gazebo, the URDF is often converted or extended into an ",(0,o.jsx)(n.strong,{children:"SDF (Simulation Description Format)"})," file, which includes additional tags specific to simulation physics and sensor models. We will explore SDF in Module 2."]}),"\n",(0,o.jsx)(n.h2,{id:"summary-key-points",children:"Summary Key Points"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"URDF is an XML format for describing a robot's kinematic, dynamic, and visual properties."}),"\n",(0,o.jsxs)(n.li,{children:["Robots are defined by ",(0,o.jsx)(n.strong,{children:"links"})," (rigid body parts) connected by ",(0,o.jsx)(n.strong,{children:"joints"})," (allowing specified motion)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Fixed"})," joints create rigid connections, while ",(0,o.jsx)(n.strong,{children:"continuous"})," joints allow unlimited rotation."]}),"\n",(0,o.jsxs)(n.li,{children:["ROS Launch Files are used to load URDF files via nodes like ",(0,o.jsx)(n.code,{children:"robot_state_publisher"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Parameter Management"})," in launch files allows configuration of nodes, such as passing the URDF path."]}),"\n",(0,o.jsxs)(n.li,{children:["URDF describes the robot's structure, but ",(0,o.jsx)(n.strong,{children:"does not specify physics"})," for simulation (SDF does this)."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"readingresearch-references-apa-7th-edition",children:"Reading/Research References (APA 7th Edition)"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["ROS 2 Documentation. (n.d.). ",(0,o.jsx)(n.em,{children:"URDF Overview"}),". Retrieved from ",(0,o.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/URDF/ROS2-URDF-Overview.html",children:"https://docs.ros.org/en/humble/Tutorials/URDF/ROS2-URDF-Overview.html"})]}),"\n",(0,o.jsxs)(n.li,{children:["ROS 2 Documentation. (n.d.). ",(0,o.jsx)(n.em,{children:"Creating a URDF Model"}),". Retrieved from ",(0,o.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/URDF/Build-a-Visual-Robot-Model-with-URDF.html",children:"https://docs.ros.org/en/humble/Tutorials/URDF/Build-a-Visual-Robot-Model-with-URDF.html"})]}),"\n",(0,o.jsxs)(n.li,{children:["ROS 2 Documentation. (n.d.). ",(0,o.jsx)(n.em,{children:"ROS 2 Launch System"}),". Retrieved from ",(0,o.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Launch-Files/Creating-a-ROS2-Launch-File.html",children:"https://docs.ros.org/en/humble/Tutorials/Launch-Files/Creating-a-ROS2-Launch-File.html"})]}),"\n",(0,o.jsxs)(n.li,{children:["Gazebo Documentation. (n.d.). ",(0,o.jsx)(n.em,{children:"SDF vs URDF"}),". Retrieved from ",(0,o.jsx)(n.a,{href:"http://classic.gazebosim.org/tutorials?tut=ros_urdf",children:"http://classic.gazebosim.org/tutorials?tut=ros_urdf"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);